import React, { PureComponent, forwardRef, useContext, useState, useCallback, useRef, useImperativeHandle } from 'react';
import Big from 'big.js';
import * as echarts from 'echarts';

var clone = {exports: {}};

(function (module) {
var clone = (function() {

function _instanceof(obj, type) {
  return type != null && obj instanceof type;
}

var nativeMap;
try {
  nativeMap = Map;
} catch(_) {
  // maybe a reference error because no `Map`. Give it a dummy value that no
  // value will ever be an instanceof.
  nativeMap = function() {};
}

var nativeSet;
try {
  nativeSet = Set;
} catch(_) {
  nativeSet = function() {};
}

var nativePromise;
try {
  nativePromise = Promise;
} catch(_) {
  nativePromise = function() {};
}

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
 * @param `includeNonEnumerable` - set to true if the non-enumerable properties
 *    should be cloned as well. Non-enumerable properties on the prototype
 *    chain will be ignored. (optional - false by default)
*/
function clone(parent, circular, depth, prototype, includeNonEnumerable) {
  if (typeof circular === 'object') {
    depth = circular.depth;
    prototype = circular.prototype;
    includeNonEnumerable = circular.includeNonEnumerable;
    circular = circular.circular;
  }
  // maintain two arrays for circular references, where corresponding parents
  // and children have the same index
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;

  // recurse this function so we don't reset allParents and allChildren
  function _clone(parent, depth) {
    // cloning null always returns null
    if (parent === null)
      return null;

    if (depth === 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != 'object') {
      return parent;
    }

    if (_instanceof(parent, nativeMap)) {
      child = new nativeMap();
    } else if (_instanceof(parent, nativeSet)) {
      child = new nativeSet();
    } else if (_instanceof(parent, nativePromise)) {
      child = new nativePromise(function (resolve, reject) {
        parent.then(function(value) {
          resolve(_clone(value, depth - 1));
        }, function(err) {
          reject(_clone(err, depth - 1));
        });
      });
    } else if (clone.__isArray(parent)) {
      child = [];
    } else if (clone.__isRegExp(parent)) {
      child = new RegExp(parent.source, __getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (clone.__isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      if (Buffer.allocUnsafe) {
        // Node.js >= 4.5.0
        child = Buffer.allocUnsafe(parent.length);
      } else {
        // Older Node.js versions
        child = new Buffer(parent.length);
      }
      parent.copy(child);
      return child;
    } else if (_instanceof(parent, Error)) {
      child = Object.create(parent);
    } else {
      if (typeof prototype == 'undefined') {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    if (_instanceof(parent, nativeMap)) {
      parent.forEach(function(value, key) {
        var keyChild = _clone(key, depth - 1);
        var valueChild = _clone(value, depth - 1);
        child.set(keyChild, valueChild);
      });
    }
    if (_instanceof(parent, nativeSet)) {
      parent.forEach(function(value) {
        var entryChild = _clone(value, depth - 1);
        child.add(entryChild);
      });
    }

    for (var i in parent) {
      var attrs;
      if (proto) {
        attrs = Object.getOwnPropertyDescriptor(proto, i);
      }

      if (attrs && attrs.set == null) {
        continue;
      }
      child[i] = _clone(parent[i], depth - 1);
    }

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(parent);
      for (var i = 0; i < symbols.length; i++) {
        // Don't need to worry about cloning a symbol because it is a primitive,
        // like a number or string.
        var symbol = symbols[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
          continue;
        }
        child[symbol] = _clone(parent[symbol], depth - 1);
        if (!descriptor.enumerable) {
          Object.defineProperty(child, symbol, {
            enumerable: false
          });
        }
      }
    }

    if (includeNonEnumerable) {
      var allPropertyNames = Object.getOwnPropertyNames(parent);
      for (var i = 0; i < allPropertyNames.length; i++) {
        var propertyName = allPropertyNames[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
        if (descriptor && descriptor.enumerable) {
          continue;
        }
        child[propertyName] = _clone(parent[propertyName], depth - 1);
        Object.defineProperty(child, propertyName, {
          enumerable: false
        });
      }
    }

    return child;
  }

  return _clone(parent, depth);
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function clonePrototype(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

// private utility functions

function __objToStr(o) {
  return Object.prototype.toString.call(o);
}
clone.__objToStr = __objToStr;

function __isDate(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Date]';
}
clone.__isDate = __isDate;

function __isArray(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Array]';
}
clone.__isArray = __isArray;

function __isRegExp(o) {
  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
}
clone.__isRegExp = __isRegExp;

function __getRegExpFlags(re) {
  var flags = '';
  if (re.global) flags += 'g';
  if (re.ignoreCase) flags += 'i';
  if (re.multiline) flags += 'm';
  return flags;
}
clone.__getRegExpFlags = __getRegExpFlags;

return clone;
})();

if (module.exports) {
  module.exports = clone;
}
}(clone));

var cloneDeep = clone.exports;

var MAX_DP = 1e6, MAX_POWER = 1e6, NAME = "[big.js] ", INVALID = NAME + "Invalid ", INVALID_DP = INVALID + "decimal places", INVALID_RM = INVALID + "rounding mode", DIV_BY_ZERO = NAME + "Division by zero", P = {}, UNDEFINED = void 0;
function round(x, sd, rm, more) {
  var xc = x.c;
  if (rm === UNDEFINED)
    rm = x.constructor.RM;
  if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {
    throw Error(INVALID_RM);
  }
  if (sd < 1) {
    more = rm === 3 && (more || !!xc[0]) || sd === 0 && (rm === 1 && xc[0] >= 5 || rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED)));
    xc.length = 1;
    if (more) {
      x.e = x.e - sd + 1;
      xc[0] = 1;
    } else {
      xc[0] = x.e = 0;
    }
  } else if (sd < xc.length) {
    more = rm === 1 && xc[sd] >= 5 || rm === 2 && (xc[sd] > 5 || xc[sd] === 5 && (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) || rm === 3 && (more || !!xc[0]);
    xc.length = sd--;
    if (more) {
      for (; ++xc[sd] > 9; ) {
        xc[sd] = 0;
        if (!sd--) {
          ++x.e;
          xc.unshift(1);
        }
      }
    }
    for (sd = xc.length; !xc[--sd]; )
      xc.pop();
  }
  return x;
}
function stringify(x, doExponential, isNonzero) {
  var e = x.e, s = x.c.join(""), n = s.length;
  if (doExponential) {
    s = s.charAt(0) + (n > 1 ? "." + s.slice(1) : "") + (e < 0 ? "e" : "e+") + e;
  } else if (e < 0) {
    for (; ++e; )
      s = "0" + s;
    s = "0." + s;
  } else if (e > 0) {
    if (++e > n) {
      for (e -= n; e--; )
        s += "0";
    } else if (e < n) {
      s = s.slice(0, e) + "." + s.slice(e);
    }
  } else if (n > 1) {
    s = s.charAt(0) + "." + s.slice(1);
  }
  return x.s < 0 && isNonzero ? "-" + s : s;
}
P.abs = function() {
  var x = new this.constructor(this);
  x.s = 1;
  return x;
};
P.cmp = function(y) {
  var isneg, x = this, xc = x.c, yc = (y = new x.constructor(y)).c, i = x.s, j = y.s, k = x.e, l = y.e;
  if (!xc[0] || !yc[0])
    return !xc[0] ? !yc[0] ? 0 : -j : i;
  if (i != j)
    return i;
  isneg = i < 0;
  if (k != l)
    return k > l ^ isneg ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i = -1; ++i < j; ) {
    if (xc[i] != yc[i])
      return xc[i] > yc[i] ^ isneg ? 1 : -1;
  }
  return k == l ? 0 : k > l ^ isneg ? 1 : -1;
};
P.div = function(y) {
  var x = this, Big2 = x.constructor, a = x.c, b = (y = new Big2(y)).c, k = x.s == y.s ? 1 : -1, dp = Big2.DP;
  if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }
  if (!b[0]) {
    throw Error(DIV_BY_ZERO);
  }
  if (!a[0]) {
    y.s = k;
    y.c = [y.e = 0];
    return y;
  }
  var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), rl = r.length, q = y, qc = q.c = [], qi = 0, p = dp + (q.e = x.e - y.e) + 1;
  q.s = k;
  k = p < 0 ? 0 : p;
  bz.unshift(0);
  for (; rl++ < bl; )
    r.push(0);
  do {
    for (n = 0; n < 10; n++) {
      if (bl != (rl = r.length)) {
        cmp = bl > rl ? 1 : -1;
      } else {
        for (ri = -1, cmp = 0; ++ri < bl; ) {
          if (b[ri] != r[ri]) {
            cmp = b[ri] > r[ri] ? 1 : -1;
            break;
          }
        }
      }
      if (cmp < 0) {
        for (bt = rl == bl ? b : bz; rl; ) {
          if (r[--rl] < bt[rl]) {
            ri = rl;
            for (; ri && !r[--ri]; )
              r[ri] = 9;
            --r[ri];
            r[rl] += 10;
          }
          r[rl] -= bt[rl];
        }
        for (; !r[0]; )
          r.shift();
      } else {
        break;
      }
    }
    qc[qi++] = cmp ? n : ++n;
    if (r[0] && cmp)
      r[rl] = a[ai] || 0;
    else
      r = [a[ai]];
  } while ((ai++ < al || r[0] !== UNDEFINED) && k--);
  if (!qc[0] && qi != 1) {
    qc.shift();
    q.e--;
    p--;
  }
  if (qi > p)
    round(q, p, Big2.RM, r[0] !== UNDEFINED);
  return q;
};
P.eq = function(y) {
  return this.cmp(y) === 0;
};
P.gt = function(y) {
  return this.cmp(y) > 0;
};
P.gte = function(y) {
  return this.cmp(y) > -1;
};
P.lt = function(y) {
  return this.cmp(y) < 0;
};
P.lte = function(y) {
  return this.cmp(y) < 1;
};
P.minus = P.sub = function(y) {
  var i, j, t, xlty, x = this, Big2 = x.constructor, a = x.s, b = (y = new Big2(y)).s;
  if (a != b) {
    y.s = -b;
    return x.plus(y);
  }
  var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;
  if (!xc[0] || !yc[0]) {
    if (yc[0]) {
      y.s = -b;
    } else if (xc[0]) {
      y = new Big2(x);
    } else {
      y.s = 1;
    }
    return y;
  }
  if (a = xe - ye) {
    if (xlty = a < 0) {
      a = -a;
      t = xc;
    } else {
      ye = xe;
      t = yc;
    }
    t.reverse();
    for (b = a; b--; )
      t.push(0);
    t.reverse();
  } else {
    j = ((xlty = xc.length < yc.length) ? xc : yc).length;
    for (a = b = 0; b < j; b++) {
      if (xc[b] != yc[b]) {
        xlty = xc[b] < yc[b];
        break;
      }
    }
  }
  if (xlty) {
    t = xc;
    xc = yc;
    yc = t;
    y.s = -y.s;
  }
  if ((b = (j = yc.length) - (i = xc.length)) > 0)
    for (; b--; )
      xc[i++] = 0;
  for (b = i; j > a; ) {
    if (xc[--j] < yc[j]) {
      for (i = j; i && !xc[--i]; )
        xc[i] = 9;
      --xc[i];
      xc[j] += 10;
    }
    xc[j] -= yc[j];
  }
  for (; xc[--b] === 0; )
    xc.pop();
  for (; xc[0] === 0; ) {
    xc.shift();
    --ye;
  }
  if (!xc[0]) {
    y.s = 1;
    xc = [ye = 0];
  }
  y.c = xc;
  y.e = ye;
  return y;
};
P.mod = function(y) {
  var ygtx, x = this, Big2 = x.constructor, a = x.s, b = (y = new Big2(y)).s;
  if (!y.c[0]) {
    throw Error(DIV_BY_ZERO);
  }
  x.s = y.s = 1;
  ygtx = y.cmp(x) == 1;
  x.s = a;
  y.s = b;
  if (ygtx)
    return new Big2(x);
  a = Big2.DP;
  b = Big2.RM;
  Big2.DP = Big2.RM = 0;
  x = x.div(y);
  Big2.DP = a;
  Big2.RM = b;
  return this.minus(x.times(y));
};
P.plus = P.add = function(y) {
  var e, k, t, x = this, Big2 = x.constructor;
  y = new Big2(y);
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  var xe = x.e, xc = x.c, ye = y.e, yc = y.c;
  if (!xc[0] || !yc[0]) {
    if (!yc[0]) {
      if (xc[0]) {
        y = new Big2(x);
      } else {
        y.s = x.s;
      }
    }
    return y;
  }
  xc = xc.slice();
  if (e = xe - ye) {
    if (e > 0) {
      ye = xe;
      t = yc;
    } else {
      e = -e;
      t = xc;
    }
    t.reverse();
    for (; e--; )
      t.push(0);
    t.reverse();
  }
  if (xc.length - yc.length < 0) {
    t = yc;
    yc = xc;
    xc = t;
  }
  e = yc.length;
  for (k = 0; e; xc[e] %= 10)
    k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;
  if (k) {
    xc.unshift(k);
    ++ye;
  }
  for (e = xc.length; xc[--e] === 0; )
    xc.pop();
  y.c = xc;
  y.e = ye;
  return y;
};
P.pow = function(n) {
  var x = this, one = new x.constructor("1"), y = one, isneg = n < 0;
  if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {
    throw Error(INVALID + "exponent");
  }
  if (isneg)
    n = -n;
  for (; ; ) {
    if (n & 1)
      y = y.times(x);
    n >>= 1;
    if (!n)
      break;
    x = x.times(x);
  }
  return isneg ? one.div(y) : y;
};
P.prec = function(sd, rm) {
  if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
    throw Error(INVALID + "precision");
  }
  return round(new this.constructor(this), sd, rm);
};
P.round = function(dp, rm) {
  if (dp === UNDEFINED)
    dp = 0;
  else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }
  return round(new this.constructor(this), dp + this.e + 1, rm);
};
P.sqrt = function() {
  var r, c, t, x = this, Big2 = x.constructor, s = x.s, e = x.e, half = new Big2("0.5");
  if (!x.c[0])
    return new Big2(x);
  if (s < 0) {
    throw Error(NAME + "No square root");
  }
  s = Math.sqrt(x + "");
  if (s === 0 || s === 1 / 0) {
    c = x.c.join("");
    if (!(c.length + e & 1))
      c += "0";
    s = Math.sqrt(c);
    e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
    r = new Big2((s == 1 / 0 ? "5e" : (s = s.toExponential()).slice(0, s.indexOf("e") + 1)) + e);
  } else {
    r = new Big2(s + "");
  }
  e = r.e + (Big2.DP += 4);
  do {
    t = r;
    r = half.times(t.plus(x.div(t)));
  } while (t.c.slice(0, e).join("") !== r.c.slice(0, e).join(""));
  return round(r, (Big2.DP -= 4) + r.e + 1, Big2.RM);
};
P.times = P.mul = function(y) {
  var c, x = this, Big2 = x.constructor, xc = x.c, yc = (y = new Big2(y)).c, a = xc.length, b = yc.length, i = x.e, j = y.e;
  y.s = x.s == y.s ? 1 : -1;
  if (!xc[0] || !yc[0]) {
    y.c = [y.e = 0];
    return y;
  }
  y.e = i + j;
  if (a < b) {
    c = xc;
    xc = yc;
    yc = c;
    j = a;
    a = b;
    b = j;
  }
  for (c = new Array(j = a + b); j--; )
    c[j] = 0;
  for (i = b; i--; ) {
    b = 0;
    for (j = a + i; j > i; ) {
      b = c[j] + yc[i] * xc[j - i - 1] + b;
      c[j--] = b % 10;
      b = b / 10 | 0;
    }
    c[j] = b;
  }
  if (b)
    ++y.e;
  else
    c.shift();
  for (i = c.length; !c[--i]; )
    c.pop();
  y.c = c;
  return y;
};
P.toExponential = function(dp, rm) {
  var x = this, n = x.c[0];
  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round(new x.constructor(x), ++dp, rm);
    for (; x.c.length < dp; )
      x.c.push(0);
  }
  return stringify(x, true, !!n);
};
P.toFixed = function(dp, rm) {
  var x = this, n = x.c[0];
  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round(new x.constructor(x), dp + x.e + 1, rm);
    for (dp = dp + x.e + 1; x.c.length < dp; )
      x.c.push(0);
  }
  return stringify(x, false, !!n);
};
P.toJSON = P.toString = function() {
  var x = this, Big2 = x.constructor;
  return stringify(x, x.e <= Big2.NE || x.e >= Big2.PE, !!x.c[0]);
};
P.toNumber = function() {
  var n = Number(stringify(this, true, true));
  if (this.constructor.strict === true && !this.eq(n.toString())) {
    throw Error(NAME + "Imprecise conversion");
  }
  return n;
};
P.toPrecision = function(sd, rm) {
  var x = this, Big2 = x.constructor, n = x.c[0];
  if (sd !== UNDEFINED) {
    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
      throw Error(INVALID + "precision");
    }
    x = round(new Big2(x), sd, rm);
    for (; x.c.length < sd; )
      x.c.push(0);
  }
  return stringify(x, sd <= x.e || x.e <= Big2.NE || x.e >= Big2.PE, !!n);
};
P.valueOf = function() {
  var x = this, Big2 = x.constructor;
  if (Big2.strict === true) {
    throw Error(NAME + "valueOf disallowed");
  }
  return stringify(x, x.e <= Big2.NE || x.e >= Big2.PE, true);
};
var __defProp$2 = Object.defineProperty;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
const COLOR_LIST = [
  "#FF7C7C",
  "#ADD4EF",
  "#BFDAA7",
  "#FCAC65",
  "#C6C1D2",
  "#7598E4",
  "#CF6D6C",
  "#4979CF",
  "#E1934B",
  "#829649",
  "#7D70AC",
  "#2559B7"
];
const mergeOption = (baseOptions, userOptions = {}) => {
  const _baseOptions = baseOptions || {};
  const _userOptions = userOptions || {};
  const _mergeOptions = __spreadValues$2(__spreadValues$2({}, _baseOptions), _userOptions);
  return _mergeOptions;
};
const truncate = (str, n) => {
  const r = /[^\x00-\xff]/g;
  let m;
  if (!str) {
    return "";
  }
  if (str.replace(r, "**").length > n) {
    m = Math.floor(n / 2);
    for (let i = m, l = str.length; i < l; i++) {
      if (str.slice(0, i).replace(r, "**").length >= n) {
        return str.slice(0, i) + "...";
      }
    }
  }
  return str;
};
React.createContext({});
const buildChartOption = (chartOptions, settings, chartType) => {
  var _a;
  const _option = chartOptions || {};
  const { legendPosition = "top" } = settings || {};
  if (legendPosition) {
    switch (legendPosition) {
      case "top":
        _option.legend.top = 60;
        _option.legend.bottom = "auto";
        _option.legend.left = "center";
        _option.legend.padding = [5, 5];
        _option.grid.top = 110;
        _option.grid.left = chartType == "scatter" ? 70 : 20;
        _option.grid.right = chartType == "scatter" ? 100 : chartType == "bar-horizontal" ? 50 : 20;
        _option.grid.bottom = chartType == "scatter" ? 100 : 45;
        _option.legend.orient = "horizontal";
        break;
      case "bottom":
        _option.legend.top = "auto";
        _option.legend.bottom = chartType == "scatter" ? 40 : 20;
        _option.legend.left = "center";
        _option.legend.padding = [5, 5];
        _option.grid.top = 70;
        _option.grid.left = chartType == "scatter" ? 70 : 20;
        _option.grid.right = chartType == "scatter" ? 50 : chartType == "bar-horizontal" ? 50 : 20;
        _option.grid.bottom = chartType == "scatter" ? 100 : 45;
        _option.legend.orient = "horizontal";
        break;
      case "left":
        _option.legend.top = 60;
        _option.legend.bottom = 60;
        _option.legend.left = 20;
        _option.legend.right = "auto";
        _option.legend.padding = [5, 5];
        _option.grid.top = 70;
        _option.grid.left = 150;
        _option.grid.right = chartType == "scatter" ? 50 : 20;
        _option.grid.bottom = chartType == "scatter" ? 100 : 20;
        _option.legend.orient = "vertical";
        break;
      case "right":
        _option.legend.top = 60;
        _option.legend.bottom = 60;
        _option.legend.left = "auto";
        _option.legend.right = chartType == "scatter" ? 50 : 20;
        _option.legend.padding = [5, 5];
        _option.grid.top = 70;
        _option.grid.left = chartType == "scatter" ? 70 : 20;
        _option.grid.right = chartType == "scatter" ? 170 : 200;
        _option.grid.bottom = chartType == "scatter" ? 100 : 20;
        _option.legend.orient = "vertical";
        break;
      default:
        _option.legend.top = "auto";
        _option.legend.bottom = "6%";
        _option.legend.left = "center";
        _option.grid.top = "18%";
        _option.grid.left = "8%";
        _option.grid.right = "8%";
        _option.grid.bottom = "15%";
        break;
    }
    if (_option.legend.show == false) {
      _option.legend.top = 60;
      _option.legend.bottom = "auto";
      _option.legend.left = "center";
      _option.legend.padding = [5, 5];
      _option.grid.top = 100;
      _option.grid.left = 20;
      _option.grid.right = chartType == "scatter" ? 50 : 20;
      _option.grid.bottom = chartType == "scatter" ? 60 : 20;
    }
  } else {
    _option.legend.top = "auto";
    _option.legend.bottom = "6%";
    _option.legend.left = "center";
    _option.grid.top = "18%";
    _option.grid.left = "8%";
    _option.grid.right = "8%";
    _option.grid.bottom = "15%";
    _option.legend.orient = "horizontal";
  }
  const iconLineWithRing = "path://M14,4h-2.1C11.4,1.7,9.4,0,7,0S2.6,1.7,2.1,4H0v2h2.1c0.5,2.3,2.5,4,4.9,4s4.4-1.7,4.9-4H14V4z M7,8  C5.3,8,4,6.7,4,5s1.3-3,3-3s3,1.3,3,3S8.7,8,7,8z";
  if (chartType == "pie") {
    _option.legend.data = _option.series[0] && _option.series[0].data.map((item) => {
      const textStyle = {
        padding: [2, 0, 0, 0]
      };
      return {
        name: item.name,
        icon: "circle",
        textStyle
      };
    });
  } else {
    const _legendData = (_a = _option.series) == null ? void 0 : _a.map((item) => {
      var _a2, _b, _c;
      let icon = "circle";
      const textStyle = {
        padding: [2, 0, 0, 0]
      };
      let itemStyle;
      if ((_c = (_b = (_a2 = item.data) == null ? void 0 : _a2[0]) == null ? void 0 : _b.itemStyle) == null ? void 0 : _c.color) {
        itemStyle = {
          color: item.data[0].itemStyle.color
        };
      }
      switch (item.type) {
        case "bar":
          icon = "circle";
          break;
        case "line":
          icon = iconLineWithRing;
          break;
      }
      return {
        name: `${item.name}`,
        icon,
        textStyle,
        itemStyle
      };
    });
    if (_option.legend.show && legendPosition && ["left", "right"].includes(legendPosition) && (chartType == "stack" || chartType == "line-stack")) {
      _option.legend.data = _legendData.reverse();
      _option.tooltip.formatter = function(data) {
        return `<div>${data[0].name}</div>${data.reverse().map((d) => {
          switch (d.seriesType) {
            case "pie":
              return `<div>
                        <span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:${d.color}"></span>
                        <span>${d.data.label ? d.data.label.formatter(d, true) : d.data.value}</span>
                    </div>`;
            default:
              return `<div>
                        <span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:${d.color}"></span>
                        <span>${d.seriesName}:</span>
                        <span>${d.data.label ? d.data.label.formatter(d, true) : d.data.value}</span>
                    </div>`;
          }
        }).join("")}`;
      };
    } else {
      _option.legend.data = _legendData;
    }
  }
  _option.legend.formatter = (text) => {
    if (isNaN(text)) {
      return truncate(text, 12);
    } else {
      return text;
    }
  };
  _option.tooltip.trigger = ["pie", "scatter"].includes(chartType) ? "item" : "axis";
  return _option;
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var lib = {};

var sensorPool = {};

var id = {};

(function (exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

/**
 * Created by hustcc on 18/6/9.
 * Contract: i@hust.cc
 */
var id = 1;
/**
 * generate unique id in application
 * @return {string}
 */

var _default = function _default() {
  return "".concat(id++);
};

exports["default"] = _default;
}(id));

var sensors = {};

var object = {};

var debounce = {};

(function (exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

/**
 * Created by hustcc on 18/6/9.
 * Contract: i@hust.cc
 */
var _default = function _default(fn) {
  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60;
  var timer = null;
  return function () {
    var _this = this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    clearTimeout(timer);
    timer = setTimeout(function () {
      fn.apply(_this, args);
    }, delay);
  };
};

exports["default"] = _default;
}(debounce));

var constant = {};

Object.defineProperty(constant, "__esModule", {
  value: true
});
constant.SensorTabIndex = constant.SensorClassName = constant.SizeSensorId = void 0;

/**
 * Created by hustcc on 18/6/9.
 * Contract: i@hust.cc
 */
var SizeSensorId = 'size-sensor-id';
constant.SizeSensorId = SizeSensorId;
var SensorClassName = 'size-sensor-object';
constant.SensorClassName = SensorClassName;
var SensorTabIndex = '-1';
constant.SensorTabIndex = SensorTabIndex;

Object.defineProperty(object, "__esModule", {
  value: true
});
object.createSensor = void 0;

var _debounce$1 = _interopRequireDefault$2(debounce);

var _constant$1 = constant;

function _interopRequireDefault$2(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Created by hustcc on 18/6/9.
 * Contract: i@hust.cc
 */
var createSensor$2 = function createSensor(element) {
  var sensor = undefined; // callback

  var listeners = [];
  /**
   * create object DOM of sensor
   * @returns {HTMLObjectElement}
   */

  var newSensor = function newSensor() {
    // adjust style
    if (getComputedStyle(element).position === 'static') {
      element.style.position = 'relative';
    }

    var obj = document.createElement('object');

    obj.onload = function () {
      obj.contentDocument.defaultView.addEventListener('resize', resizeListener); // 直接触发一次 resize

      resizeListener();
    };

    obj.style.display = 'block';
    obj.style.position = 'absolute';
    obj.style.top = '0';
    obj.style.left = '0';
    obj.style.height = '100%';
    obj.style.width = '100%';
    obj.style.overflow = 'hidden';
    obj.style.pointerEvents = 'none';
    obj.style.zIndex = '-1';
    obj.style.opacity = '0';
    obj.setAttribute('class', _constant$1.SensorClassName);
    obj.setAttribute('tabindex', _constant$1.SensorTabIndex);
    obj.type = 'text/html'; // append into dom

    element.appendChild(obj); // for ie, should set data attribute delay, or will be white screen

    obj.data = 'about:blank';
    return obj;
  };
  /**
   * trigger listeners
   */


  var resizeListener = (0, _debounce$1["default"])(function () {
    // trigger all listener
    listeners.forEach(function (listener) {
      listener(element);
    });
  });
  /**
   * listen with one callback function
   * @param cb
   */

  var bind = function bind(cb) {
    // if not exist sensor, then create one
    if (!sensor) {
      sensor = newSensor();
    }

    if (listeners.indexOf(cb) === -1) {
      listeners.push(cb);
    }
  };
  /**
   * destroy all
   */


  var destroy = function destroy() {
    if (sensor && sensor.parentNode) {
      if (sensor.contentDocument) {
        // remote event
        sensor.contentDocument.defaultView.removeEventListener('resize', resizeListener);
      } // remove dom


      sensor.parentNode.removeChild(sensor); // initial variable

      sensor = undefined;
      listeners = [];
    }
  };
  /**
   * cancel listener bind
   * @param cb
   */


  var unbind = function unbind(cb) {
    var idx = listeners.indexOf(cb);

    if (idx !== -1) {
      listeners.splice(idx, 1);
    } // no listener, and sensor is exist
    // then destroy the sensor


    if (listeners.length === 0 && sensor) {
      destroy();
    }
  };

  return {
    element: element,
    bind: bind,
    destroy: destroy,
    unbind: unbind
  };
};

object.createSensor = createSensor$2;

var resizeObserver = {};

Object.defineProperty(resizeObserver, "__esModule", {
  value: true
});
resizeObserver.createSensor = void 0;

var _debounce = _interopRequireDefault$1(debounce);

function _interopRequireDefault$1(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Created by hustcc on 18/7/5.
 * Contract: i@hust.cc
 */
var createSensor$1 = function createSensor(element) {
  var sensor = undefined; // callback

  var listeners = [];
  /**
   * trigger listeners
   */

  var resizeListener = (0, _debounce["default"])(function () {
    // trigger all
    listeners.forEach(function (listener) {
      listener(element);
    });
  });
  /**
   * create ResizeObserver sensor
   * @returns
   */

  var newSensor = function newSensor() {
    var s = new ResizeObserver(resizeListener); // listen element

    s.observe(element); // trigger once

    resizeListener();
    return s;
  };
  /**
   * listen with callback
   * @param cb
   */


  var bind = function bind(cb) {
    if (!sensor) {
      sensor = newSensor();
    }

    if (listeners.indexOf(cb) === -1) {
      listeners.push(cb);
    }
  };
  /**
   * destroy
   */


  var destroy = function destroy() {
    sensor.disconnect();
    listeners = [];
    sensor = undefined;
  };
  /**
   * cancel bind
   * @param cb
   */


  var unbind = function unbind(cb) {
    var idx = listeners.indexOf(cb);

    if (idx !== -1) {
      listeners.splice(idx, 1);
    } // no listener, and sensor is exist
    // then destroy the sensor


    if (listeners.length === 0 && sensor) {
      destroy();
    }
  };

  return {
    element: element,
    bind: bind,
    destroy: destroy,
    unbind: unbind
  };
};

resizeObserver.createSensor = createSensor$1;

Object.defineProperty(sensors, "__esModule", {
  value: true
});
sensors.createSensor = void 0;

var _object = object;

var _resizeObserver = resizeObserver;

/**
 * Created by hustcc on 18/7/5.
 * Contract: i@hust.cc
 */

/**
 * sensor strategies
 */
// export const createSensor = createObjectSensor;
var createSensor = typeof ResizeObserver !== 'undefined' ? _resizeObserver.createSensor : _object.createSensor;
sensors.createSensor = createSensor;

Object.defineProperty(sensorPool, "__esModule", {
  value: true
});
sensorPool.removeSensor = sensorPool.getSensor = void 0;

var _id = _interopRequireDefault(id);

var _sensors = sensors;

var _constant = constant;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Created by hustcc on 18/6/9.
 * Contract: i@hust.cc
 */

/**
 * all the sensor objects.
 * sensor pool
 */
var Sensors = {};
/**
 * get one sensor
 * @param element
 * @returns {*}
 */

var getSensor = function getSensor(element) {
  var sensorId = element.getAttribute(_constant.SizeSensorId); // 1. if the sensor exists, then use it

  if (sensorId && Sensors[sensorId]) {
    return Sensors[sensorId];
  } // 2. not exist, then create one


  var newId = (0, _id["default"])();
  element.setAttribute(_constant.SizeSensorId, newId);
  var sensor = (0, _sensors.createSensor)(element); // add sensor into pool

  Sensors[newId] = sensor;
  return sensor;
};
/**
 * 移除 sensor
 * @param sensor
 */


sensorPool.getSensor = getSensor;

var removeSensor = function removeSensor(sensor) {
  var sensorId = sensor.element.getAttribute(_constant.SizeSensorId); // remove attribute

  sensor.element.removeAttribute(_constant.SizeSensorId); // remove event, dom of the sensor used

  sensor.destroy(); // exist, then remove from pool

  if (sensorId && Sensors[sensorId]) {
    delete Sensors[sensorId];
  }
};

sensorPool.removeSensor = removeSensor;

Object.defineProperty(lib, "__esModule", {
  value: true
});
lib.ver = clear_1 = lib.clear = bind_1 = lib.bind = void 0;

var _sensorPool = sensorPool;

/**
 * Created by hustcc on 18/6/9.[高考时间]
 * Contract: i@hust.cc
 */

/**
 * bind an element with resize callback function
 * @param {*} element
 * @param {*} cb
 */
var bind = function bind(element, cb) {
  var sensor = (0, _sensorPool.getSensor)(element); // listen with callback

  sensor.bind(cb); // return unbind function

  return function () {
    sensor.unbind(cb);
  };
};
/**
 * clear all the listener and sensor of an element
 * @param element
 */


var bind_1 = lib.bind = bind;

var clear = function clear(element) {
  var sensor = (0, _sensorPool.getSensor)(element);
  (0, _sensorPool.removeSensor)(sensor);
};

var clear_1 = lib.clear = clear;
var ver = "1.0.1";
lib.ver = ver;

/**
 * 保留 object 中的部分内容
 * @param obj
 * @param keys
 */
function pick(obj, keys) {
    var r = {};
    keys.forEach(function (key) {
        r[key] = obj[key];
    });
    return r;
}

function isFunction(v) {
    return typeof v === 'function';
}

function isString(v) {
    return typeof v === 'string';
}

// do not edit .js files directly - edit src/index.jst



var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

/**
 * core component for echarts binding
 */
var EChartsReactCore = /** @class */ (function (_super) {
    __extends(EChartsReactCore, _super);
    function EChartsReactCore(props) {
        var _this = _super.call(this, props) || this;
        _this.echarts = props.echarts;
        _this.ele = null;
        _this.isInitialResize = true;
        return _this;
    }
    EChartsReactCore.prototype.componentDidMount = function () {
        this.renderNewEcharts();
    };
    // update
    EChartsReactCore.prototype.componentDidUpdate = function (prevProps) {
        /**
         * if shouldSetOption return false, then return, not update echarts options
         * default is true
         */
        var shouldSetOption = this.props.shouldSetOption;
        if (isFunction(shouldSetOption) && !shouldSetOption(prevProps, this.props)) {
            return;
        }
        // 以下属性修改的时候，需要 dispose 之后再新建
        // 1. 切换 theme 的时候
        // 2. 修改 opts 的时候
        // 3. 修改 onEvents 的时候，这样可以取消所有之前绑定的事件 issue #151
        if (!fastDeepEqual(prevProps.theme, this.props.theme) ||
            !fastDeepEqual(prevProps.opts, this.props.opts) ||
            !fastDeepEqual(prevProps.onEvents, this.props.onEvents)) {
            this.dispose();
            this.renderNewEcharts(); // 重建
            return;
        }
        // when these props are not isEqual, update echarts
        var pickKeys = ['option', 'notMerge', 'lazyUpdate', 'showLoading', 'loadingOption'];
        if (!fastDeepEqual(pick(this.props, pickKeys), pick(prevProps, pickKeys))) {
            this.updateEChartsOption();
        }
        /**
         * when style or class name updated, change size.
         */
        if (!fastDeepEqual(prevProps.style, this.props.style) || !fastDeepEqual(prevProps.className, this.props.className)) {
            this.resize();
        }
    };
    EChartsReactCore.prototype.componentWillUnmount = function () {
        this.dispose();
    };
    /**
     * return the echart object
     * 1. if exist, return the existed instance
     * 2. or new one instance
     */
    EChartsReactCore.prototype.getEchartsInstance = function () {
        return this.echarts.getInstanceByDom(this.ele) || this.echarts.init(this.ele, this.props.theme, this.props.opts);
    };
    /**
     * dispose echarts and clear size-sensor
     */
    EChartsReactCore.prototype.dispose = function () {
        if (this.ele) {
            try {
                clear_1(this.ele);
            }
            catch (e) {
                console.warn(e);
            }
            // dispose echarts instance
            this.echarts.dispose(this.ele);
        }
    };
    /**
     * render a new echarts instance
     */
    EChartsReactCore.prototype.renderNewEcharts = function () {
        var _this = this;
        var _a = this.props, onEvents = _a.onEvents, onChartReady = _a.onChartReady;
        // 1. new echarts instance
        var echartsInstance = this.updateEChartsOption();
        // 2. bind events
        this.bindEvents(echartsInstance, onEvents || {});
        // 3. on chart ready
        if (isFunction(onChartReady))
            onChartReady(echartsInstance);
        // 4. on resize
        if (this.ele) {
            bind_1(this.ele, function () {
                _this.resize();
            });
        }
    };
    // bind the events
    EChartsReactCore.prototype.bindEvents = function (instance, events) {
        function _bindEvent(eventName, func) {
            // ignore the event config which not satisfy
            if (isString(eventName) && isFunction(func)) {
                // binding event
                instance.on(eventName, function (param) {
                    func(param, instance);
                });
            }
        }
        // loop and bind
        for (var eventName in events) {
            if (Object.prototype.hasOwnProperty.call(events, eventName)) {
                _bindEvent(eventName, events[eventName]);
            }
        }
    };
    /**
     * render the echarts
     */
    EChartsReactCore.prototype.updateEChartsOption = function () {
        var _a = this.props, option = _a.option, _b = _a.notMerge, notMerge = _b === void 0 ? false : _b, _c = _a.lazyUpdate, lazyUpdate = _c === void 0 ? false : _c, showLoading = _a.showLoading, _d = _a.loadingOption, loadingOption = _d === void 0 ? null : _d;
        // 1. get or initial the echarts object
        var echartInstance = this.getEchartsInstance();
        // 2. set the echarts option
        echartInstance.setOption(option, notMerge, lazyUpdate);
        // 3. set loading mask
        if (showLoading)
            echartInstance.showLoading(loadingOption);
        else
            echartInstance.hideLoading();
        return echartInstance;
    };
    /**
     * resize wrapper
     */
    EChartsReactCore.prototype.resize = function () {
        // 1. get the echarts object
        var echartsInstance = this.getEchartsInstance();
        // 2. call echarts instance resize if not the initial resize
        // resize should not happen on first render as it will cancel initial echarts animations
        if (!this.isInitialResize) {
            try {
                echartsInstance.resize();
            }
            catch (e) {
                console.warn(e);
            }
        }
        // 3. update variable for future calls
        this.isInitialResize = false;
    };
    EChartsReactCore.prototype.render = function () {
        var _this = this;
        var _a = this.props, style = _a.style, _b = _a.className, className = _b === void 0 ? '' : _b;
        // default height = 300
        var newStyle = __assign({ height: 300 }, style);
        return (React.createElement("div", { ref: function (e) {
                _this.ele = e;
            }, style: newStyle, className: "echarts-for-react " + className }));
    };
    return EChartsReactCore;
}(PureComponent));

// export the Component the echarts Object.
var EChartsReact = /** @class */ (function (_super) {
    __extends(EChartsReact, _super);
    function EChartsReact(props) {
        var _this = _super.call(this, props) || this;
        // 初始化为 echarts 整个包
        _this.echarts = echarts;
        return _this;
    }
    return EChartsReact;
}(EChartsReactCore));

var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Scatter = forwardRef((props, ref) => {
  const _a = props, {
    context,
    dimension,
    compareDimension,
    valueList,
    echartsSeries,
    setOption,
    minDotSize,
    maxDotSize,
    colorMap
  } = _a, restSettings = __objRest(_a, [
    "context",
    "dimension",
    "compareDimension",
    "valueList",
    "echartsSeries",
    "setOption",
    "minDotSize",
    "maxDotSize",
    "colorMap"
  ]);
  const { data, echartsOptions, echartsOptionsBase: chartOption, userOptions } = useContext(context);
  const _b = echartsOptions || {}, resetOptions = __objRest(_b, ["option"]);
  if (!data) {
    return null;
  }
  const _dimension = dimension && dimension.slice(0, 1);
  const _valueList = valueList && valueList.slice(0, 3);
  const _chartOption = cloneDeep(chartOption || {});
  if (!_dimension || !_valueList || _dimension.length < 1 || _valueList.length < 2) {
    return null;
  }
  const [dataZoomX, setDataZoomX] = useState(null);
  const [dataZoomY, setDataZoomY] = useState(null);
  if (_chartOption) {
    if (compareDimension && compareDimension.length > 0) {
      let _preProcessData = [];
      let _processData = [];
      let compareDimensionValues = [];
      let dotValueMin = 100;
      let dotValueMax = 0;
      compareDimensionValues = [
        ...new Set(data == null ? void 0 : data.map((d) => d[compareDimension[0] && compareDimension[0].fieldKey]))
      ];
      data == null ? void 0 : data.forEach((d) => {
        const _index = _preProcessData.findIndex((item) => item.name == d[_dimension[0] && _dimension[0].fieldKey]);
        if (_index != -1) {
          _preProcessData[_index].data.push(d);
        } else {
          _preProcessData.push({
            name: d[_dimension[0] && _dimension[0].fieldKey],
            data: [d]
          });
        }
      });
      _processData = compareDimensionValues.map((item) => {
        return {
          name: item,
          data: _preProcessData.map((pd) => {
            const v = pd.data.find((d) => d[compareDimension[0] && compareDimension[0].fieldKey] == item);
            if (v) {
              if (valueList.length == 3) {
                dotValueMin = Math.min(v[valueList[2].fieldKey], dotValueMin);
                dotValueMax = Math.max(v[valueList[2].fieldKey], dotValueMax);
              }
              return v;
            } else {
              const _v = {};
              _v[_dimension[0] && _dimension[0].fieldKey] = pd.name;
              return _v;
            }
          })
        };
      });
      let userColorFromSetOption = null;
      if (setOption) {
        const option2 = setOption(cloneDeep(_chartOption));
        userColorFromSetOption = option2.color;
      }
      const getColor = useCallback((index) => {
        let userColor = userOptions == null ? void 0 : userOptions.color;
        if (userColorFromSetOption) {
          return userColorFromSetOption[index % userColorFromSetOption.length];
        } else if (userColor) {
          return userColor[index % userColor.length];
        } else {
          return COLOR_LIST[index % COLOR_LIST.length];
        }
      }, [userOptions == null ? void 0 : userOptions.color, userColorFromSetOption]);
      const minSymbolSize = minDotSize != null ? minDotSize : 50;
      const maxSymbolSize = maxDotSize != null ? maxDotSize : 100;
      const getSymbolSize = useCallback((dotValue) => {
        const scale = _valueList.length === 3 ? Big(dotValueMax - dotValueMin).div(maxSymbolSize - minSymbolSize).toNumber() || 1 : 1;
        return _valueList.length === 3 ? Big(dotValue - dotValueMin).div(scale).plus(minSymbolSize).round(2).toNumber() : 80;
      }, [getColor]);
      _chartOption.grid.x = 70;
      _chartOption.grid.x2 = 130;
      _chartOption.grid.top = 50;
      _chartOption.grid.bottom = 130;
      _chartOption.xAxis.name = _valueList[0].fieldName;
      _chartOption.xAxis.nameLocation = "center";
      _chartOption.xAxis.nameTextStyle = {
        color: "#666"
      };
      _chartOption.xAxis.nameGap = 40;
      _chartOption.xAxis.type = "value";
      _chartOption.xAxis.show = true;
      _chartOption.xAxis.axisLabel.formatter = (value) => {
        return `${value}${_valueList[0].isPercent ? "%" : ""}`;
      };
      _chartOption.yAxis[0].show = true;
      _chartOption.yAxis[0].name = _valueList[1].fieldName;
      _chartOption.yAxis[0].nameGap = 60;
      _chartOption.yAxis[0].nameLocation = "center";
      _chartOption.yAxis[0].nameTextStyle = {
        color: "#666"
      };
      _chartOption.yAxis[0].axisLabel.formatter = (value) => {
        return `${value}${_valueList[1].isPercent ? "%" : ""}`;
      };
      _chartOption.xAxis.boundaryGap = ["1%", "1%"];
      _chartOption.xAxis.axisLine.show = false;
      _chartOption.xAxis.axisTick.show = false;
      _chartOption.xAxis.offset = 20;
      _chartOption.yAxis[0].axisLine.show = false;
      _chartOption.yAxis[0].axisTick.show = false;
      _chartOption.yAxis[0].boundaryGap = ["1%", "1%"];
      _chartOption.yAxis[0].offset = 20;
      _chartOption.tooltip = {
        show: true,
        trigger: "item",
        backgroundColor: "rgba(255,255,255,0.9)",
        extraCssText: "box-shadow: 0px 0px 4px 0px rgba(0,0,0,0.25); border-radius: 2px; padding:10px 14px",
        formatter: (item) => {
          return `<div style="color: #c8c8c8;">
                  <span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:${item.color}"></span>
                  <span>${item.name}:</span>
                  <div><span style="color: #595959;">${_valueList[0].fieldName}</span>:<span style="color: #262626;">${item.value[0]}${_valueList[0].isPercent ? "%" : ""}</span></div>
                  <div><span style="color: #595959;">${_valueList[1].fieldName}</span>:<span style="color: #262626;">${item.value[1]}${_valueList[1].isPercent ? "%" : ""}</span></div>
              </div>`;
        }
      };
      _chartOption.series = echartsSeries || _processData.map((pd, i) => {
        const _d = pd.data && pd.data.map((d, j) => {
          let itemColor = getColor(i);
          if (colorMap && colorMap.length > 0) {
            const foudColor = colorMap.find((item) => item.name === pd.name);
            if (foudColor) {
              itemColor = foudColor.color;
            }
          }
          let _value = [
            ..._valueList.map((v) => {
              let _v = void 0;
              if (d[v.fieldKey] != null) {
                _v = Big(d[v.fieldKey]);
                if (v.isPercent) {
                  _v = _v.times(100);
                }
                _v = _v.round(v.decimalLength || 0).toNumber();
              }
              return _v;
            }),
            d
          ];
          return {
            name: pd.name + "-" + d[_dimension[0].fieldKey],
            value: _value,
            itemStyle: {
              color: itemColor
            },
            label: {
              show: true,
              position: "inside",
              color: "#000",
              formatter: (params) => {
                const {
                  data: { name }
                } = params;
                return truncate(name, 6);
              },
              fontSize: 12,
              rich: {
                text: {
                  color: "#000"
                }
              }
            }
          };
        }) || [];
        return {
          name: pd.name,
          type: "scatter",
          symbolSize: (item) => {
            return item[2] != null ? getSymbolSize(item[2]) : 20;
          },
          data: _d
        };
      });
      let xMin = 0, xMax = 0, yMin = 0, yMax = 0;
      _processData == null ? void 0 : _processData.forEach((item) => {
        item.data.forEach((d) => {
          xMin = Math.min(Big(d[_valueList[0].fieldKey] || 0).round(0).toNumber(), xMin);
          xMax = Math.max(Big(d[_valueList[0].fieldKey] || 0).round(0).toNumber(), xMax);
          yMin = Math.min(Big(d[_valueList[1].fieldKey] || 0).round(0).toNumber(), yMin);
          yMax = Math.max(Big(d[_valueList[1].fieldKey] || 0).round(0).toNumber(), yMax);
        });
      });
      if (_valueList[0].isPercent) {
        xMin = Big(xMin).times(100).toNumber();
        xMax = Big(xMax).times(100).toNumber();
      }
      if (_valueList[1].isPercent) {
        yMin = Big(yMin).times(100).toNumber();
        yMax = Big(yMax).times(100).toNumber();
      }
      const _dataZoom = [];
      if (dataZoomX) {
        _dataZoom.push({
          type: "slider",
          show: true,
          xAxisIndex: [0],
          bottom: 30,
          start: dataZoomX.start,
          end: dataZoomX.end,
          throttle: 150
        });
      } else {
        _dataZoom.push({
          type: "slider",
          show: true,
          xAxisIndex: [0],
          bottom: 30,
          startValue: xMin || 0,
          endValue: xMax && Big(xMax).plus(Big(xMax).times(0.1).abs().toNumber()).toNumber() || 100,
          throttle: 150
        });
      }
      if (dataZoomY) {
        _dataZoom.push({
          type: "slider",
          show: true,
          yAxisIndex: [0],
          right: 30,
          start: dataZoomY.start,
          end: dataZoomY.end
        });
      } else {
        _dataZoom.push({
          type: "slider",
          show: true,
          yAxisIndex: [0],
          right: 30,
          startValue: yMin || 0,
          endValue: yMax || 100
        });
      }
      _chartOption.dataZoom = _dataZoom;
      _chartOption.xAxis.max = xMax && Big(xMax).plus(Big(xMax).times(0.1).abs().toNumber()).toNumber() || 100;
      _chartOption.yAxis[0].max = yMax && Big(yMax).plus(Big(yMax).times(0.1).abs().toNumber()).toNumber() || 100;
      _chartOption.xAxis.axisLabel.formatter = (value) => {
        if (xMax <= 100 && value > 100) {
          return "";
        }
        return `${value}${_valueList[0].isPercent ? "%" : ""}`;
      };
      _chartOption.yAxis[0].axisLabel.formatter = (value) => {
        if (yMax <= 100 && value > 100) {
          return "";
        }
        return `${value}${_valueList[1].isPercent ? "%" : ""}`;
      };
    } else {
      const processedData = data == null ? void 0 : data.map((d) => {
        const values = new Array(_valueList.length).fill(0);
        _valueList.map((v, i) => {
          if (d[v.fieldKey] != null) {
            values[i] = Big(d[v.fieldKey]);
            if (v.isPercent) {
              values[i] = values[i].times(100);
            }
            values[i] = values[i].round(v.decimalLength || 0).toNumber();
          }
        });
        if (_valueList.length === 3) {
          return [...values, d[_dimension[0].fieldKey], d];
        } else {
          return [...values, 1, d[_dimension[0].fieldKey], d];
        }
      });
      let userColorFromSetOption = null;
      if (setOption) {
        const option2 = setOption(cloneDeep(_chartOption));
        userColorFromSetOption = option2.color;
      }
      const getColor = useCallback((index) => {
        let userColor = userOptions == null ? void 0 : userOptions.color;
        if (userColorFromSetOption) {
          return userColorFromSetOption[index % userColorFromSetOption.length];
        } else if (userColor) {
          return userColor[index % userColor.length];
        } else {
          return COLOR_LIST[index % COLOR_LIST.length];
        }
      }, [userOptions == null ? void 0 : userOptions.color, userColorFromSetOption]);
      const minSymbolSize = minDotSize != null ? minDotSize : 50;
      const maxSymbolSize = maxDotSize != null ? maxDotSize : 100;
      const getSymbolSize = useCallback((list) => {
        const symbolList = list.map((item) => item[2]).sort((value1, value2) => {
          return value1 - value2;
        });
        const min = symbolList[0];
        const max = symbolList[symbolList.length - 1];
        const scale = _valueList.length === 3 ? Big(max - min).div(maxSymbolSize - minSymbolSize).toNumber() || 1 : 1;
        list.forEach((item, index) => {
          item[5] = _valueList.length === 3 ? Big(item[2] - min).div(scale).plus(minSymbolSize).round(2).toNumber() : 80;
          item[6] = getColor(index);
        });
        return list;
      }, [getColor]);
      _chartOption.grid.x = 70;
      _chartOption.grid.x2 = 130;
      _chartOption.grid.top = 50;
      _chartOption.grid.bottom = 130;
      _chartOption.xAxis.name = _valueList[0].fieldName;
      _chartOption.xAxis.nameLocation = "center";
      _chartOption.xAxis.nameTextStyle = {
        color: "#666"
      };
      _chartOption.xAxis.nameGap = 40;
      _chartOption.xAxis.type = "value";
      _chartOption.xAxis.show = true;
      _chartOption.xAxis.axisLabel.formatter = (value) => {
        return `${value}${_valueList[0].isPercent ? "%" : ""}`;
      };
      _chartOption.yAxis[0].show = true;
      _chartOption.yAxis[0].name = _valueList[1].fieldName;
      _chartOption.yAxis[0].nameGap = 60;
      _chartOption.yAxis[0].nameLocation = "center";
      _chartOption.yAxis[0].nameTextStyle = {
        color: "#666"
      };
      _chartOption.yAxis[0].axisLabel.formatter = (value) => {
        return `${value}${_valueList[1].isPercent ? "%" : ""}`;
      };
      _chartOption.xAxis.boundaryGap = ["1%", "1%"];
      _chartOption.xAxis.axisLine.show = false;
      _chartOption.xAxis.axisTick.show = false;
      _chartOption.xAxis.offset = 20;
      _chartOption.yAxis[0].axisLine.show = false;
      _chartOption.yAxis[0].axisTick.show = false;
      _chartOption.yAxis[0].boundaryGap = ["1%", "1%"];
      _chartOption.yAxis[0].offset = 20;
      _chartOption.tooltip = {
        show: true,
        trigger: "item",
        backgroundColor: "rgba(255,255,255,0.9)",
        extraCssText: "box-shadow: 0px 0px 4px 0px rgba(0,0,0,0.25); border-radius: 2px; padding:10px 14px",
        formatter: (item) => {
          return `<div style="color: #c8c8c8;">
                  <span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:${item.color}"></span>
                  <span>${item.name}:</span>
                  <div><span style="color: #595959;">${_valueList[0].fieldName}</span>:<span style="color: #262626;">${item.value[0]}${_valueList[0].isPercent ? "%" : ""}</span></div>
                  <div><span style="color: #595959;">${_valueList[1].fieldName}</span>:<span style="color: #262626;">${item.value[1]}${_valueList[1].isPercent ? "%" : ""}</span></div>
              </div>`;
        }
      };
      _chartOption.series = echartsSeries || [
        {
          type: "scatter",
          symbolSize: (data2) => {
            return data2[5];
          },
          itemStyle: {
            normal: {
              color: (seriesIndex) => {
                return seriesIndex.value[6];
              }
            }
          },
          data: getSymbolSize(processedData || []).map((item) => {
            return {
              name: `${item[3]}`,
              value: item,
              label: {
                show: true,
                position: "inside",
                color: "#000",
                formatter: (params) => {
                  const {
                    data: { name }
                  } = params;
                  return truncate(name, 6);
                },
                fontSize: 12,
                rich: {
                  text: {
                    color: "#000"
                  }
                }
              }
            };
          })
        }
      ];
      let xMin = processedData && processedData[0] && processedData[0][0], xMax = processedData && processedData[0] && processedData[0][0], yMin = processedData && processedData[0] && processedData[0][1], yMax = processedData && processedData[0] && processedData[0][1];
      processedData == null ? void 0 : processedData.forEach((item) => {
        xMin = Math.min(item[0], xMin);
        xMax = Math.max(item[0], xMax);
        yMin = Math.min(item[1], yMin);
        yMax = Math.max(item[1], yMax);
      });
      const _dataZoom = [];
      if (dataZoomX) {
        _dataZoom.push({
          type: "slider",
          show: true,
          xAxisIndex: [0],
          bottom: 30,
          start: dataZoomX.start,
          end: dataZoomX.end,
          throttle: 150
        });
      } else {
        _dataZoom.push({
          type: "slider",
          show: true,
          xAxisIndex: [0],
          bottom: 30,
          startValue: xMin || 0,
          endValue: xMax && Big(xMax).plus(Big(xMax).times(0.1).abs().toNumber()).toNumber() || 100,
          throttle: 150
        });
      }
      if (dataZoomY) {
        _dataZoom.push({
          type: "slider",
          show: true,
          yAxisIndex: [0],
          right: 30,
          start: dataZoomY.start,
          end: dataZoomY.end
        });
      } else {
        _dataZoom.push({
          type: "slider",
          show: true,
          yAxisIndex: [0],
          right: 30,
          startValue: yMin || 0,
          endValue: yMax || 100
        });
      }
      _chartOption.dataZoom = _dataZoom;
      _chartOption.xAxis.max = xMax && Big(xMax).plus(Big(xMax).times(0.1).abs().toNumber()).toNumber() || 100;
      _chartOption.xAxis.axisLabel.formatter = (value) => {
        if (xMax <= 100 && value > 100) {
          return "";
        }
        return `${value}${_valueList[0].isPercent ? "%" : ""}`;
      };
    }
  }
  const builtOption = buildChartOption(_chartOption, restSettings, "scatter");
  let options = mergeOption(builtOption, userOptions);
  if (setOption) {
    options = setOption(cloneDeep(options));
  }
  const onDataZoomChange = useCallback((params) => {
    if (params.dataZoomId == "\0series\x000\x000") {
      setDataZoomX({
        start: params == null ? void 0 : params.start,
        end: params == null ? void 0 : params.end
      });
    } else if (params.dataZoomId == "\0series\x001\x000") {
      setDataZoomY({
        start: params == null ? void 0 : params.start,
        end: params == null ? void 0 : params.end
      });
    }
  }, []);
  const onEvents = {
    datazoom: onDataZoomChange
  };
  const reactEchartsRef = useRef(null);
  useImperativeHandle(ref, () => ({
    getEchartsInstance: () => {
      var _a2;
      return (_a2 = reactEchartsRef == null ? void 0 : reactEchartsRef.current) == null ? void 0 : _a2.getEchartsInstance();
    }
  }), [reactEchartsRef]);
  return /* @__PURE__ */ React.createElement(EChartsReact, __spreadValues$1({
    ref: (e) => {
      reactEchartsRef.current = e;
    },
    option: __spreadValues$1({}, cloneDeep(options)),
    notMerge: true,
    opts: { renderer: "svg" },
    style: { height: "100%", width: "100%" },
    onEvents
  }, resetOptions));
});

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
const quadrantSetting = (option, quadrantSettingOption) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  if (quadrantSettingOption && quadrantSettingOption.show) {
    const _data = Array.isArray(option.series) && ((_a = option.series) == null ? void 0 : _a.length) ? cloneDeep(option.series[0].data) : null;
    const len = _data && _data.length;
    if (len) {
      const { quadrantType, quadrant1Name, quadrant2Name, quadrant3Name, quadrant4Name, bgColors } = quadrantSettingOption;
      let maxX = 0;
      let maxY = 0;
      let medianX = 0;
      let medianY = 0;
      _data.map((item) => {
        maxX = Math.max(item.value[0], maxX);
        maxY = Math.max(item.value[1], maxY);
        return item;
      });
      if (len && quadrantType === "median") {
        const medianXDataList = cloneDeep(_data).sort((prev, next) => prev.value[0] - next.value[0]);
        const medianYDataList = cloneDeep(_data).sort((prev, next) => prev.value[1] - next.value[1]);
        medianX = len % 2 === 1 ? (_b = medianXDataList[Math.floor(len / 2)]) == null ? void 0 : _b.value[0] : (((_c = medianXDataList[Math.floor(len / 2) - 1]) == null ? void 0 : _c.value[0]) + ((_d = medianXDataList[Math.floor(len / 2)]) == null ? void 0 : _d.value[0])) / 2;
        medianY = len % 2 === 1 ? (_e = medianYDataList[Math.floor(len / 2)]) == null ? void 0 : _e.value[1] : (((_f = medianYDataList[Math.floor(len / 2) - 1]) == null ? void 0 : _f.value[1]) + ((_g = medianYDataList[Math.floor(len / 2)]) == null ? void 0 : _g.value[1])) / 2;
      }
      option.xAxis = option.xAxis || {};
      if (!Array.isArray(option.xAxis)) {
        option.xAxis.max = maxX;
      }
      option.grid = option.grid || {};
      if (!Array.isArray(option.grid)) {
        option.grid.right = 70;
      }
      if (Array.isArray(option.series) && ((_h = option.series) == null ? void 0 : _h[0])) {
        option.series[0].markLine = __spreadValues(__spreadValues({}, option.series[0].markLine), {
          silent: true,
          symbol: "none",
          label: {
            show: false
          },
          lineStyle: {
            normal: {
              color: "rgba(255,255,255,0.5)",
              type: "dotted",
              width: 1
            }
          },
          data: quadrantType === "equal" ? [
            [
              { xAxis: "0", yAxis: `${maxY / 2}` },
              { xAxis: "max", yAxis: `${maxY / 2}` }
            ],
            [
              { xAxis: `${maxX / 2}`, yAxis: "0" },
              { xAxis: `${maxX / 2}`, yAxis: "max" }
            ]
          ] : [
            {
              type: quadrantType,
              valueIndex: 0
            },
            {
              valueIndex: 1,
              type: quadrantType
            }
          ]
        });
        option.series[0].markArea = __spreadValues(__spreadValues({}, option.series[0].markArea), {
          silent: true,
          label: {
            position: "insideTop"
          },
          data: [
            [
              {
                name: quadrant1Name,
                itemStyle: {
                  color: bgColors[0]
                },
                xAxis: quadrantType === "equal" ? `${maxX / 2}` : quadrantType === "median" ? `${medianX}` : quadrantType,
                yAxis: quadrantType === "equal" ? `${maxY / 2}` : quadrantType === "median" ? `${medianY}` : quadrantType
              },
              {
                xAxis: "max",
                yAxis: "max"
              }
            ],
            [
              {
                name: quadrant2Name,
                itemStyle: {
                  color: bgColors[1]
                },
                xAxis: quadrantType === "equal" ? `${maxX / 2}` : quadrantType === "median" ? `${medianX}` : quadrantType,
                yAxis: 0
              },
              {
                xAxis: "max",
                yAxis: quadrantType === "equal" ? `${maxY / 2}` : quadrantType === "median" ? `${medianY}` : quadrantType
              }
            ],
            [
              {
                name: quadrant4Name,
                itemStyle: {
                  color: bgColors[3]
                },
                xAxis: 0,
                yAxis: quadrantType === "equal" ? `${maxY / 2}` : quadrantType === "median" ? `${medianY}` : quadrantType
              },
              {
                xAxis: quadrantType === "equal" ? `${maxX / 2}` : quadrantType === "median" ? `${medianX}` : quadrantType,
                yAxis: "max"
              }
            ],
            [
              {
                name: quadrant3Name,
                itemStyle: {
                  color: bgColors[2]
                },
                xAxis: 0,
                yAxis: 0
              },
              {
                xAxis: quadrantType === "equal" ? `${maxX / 2}` : quadrantType === "median" ? `${medianX}` : quadrantType,
                yAxis: quadrantType === "equal" ? `${maxY / 2}` : quadrantType === "median" ? `${medianY}` : quadrantType
              }
            ]
          ]
        });
      }
    }
  }
};

export { Scatter, quadrantSetting };
